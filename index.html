<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Elemental Slayer 3D ‚ö°üõ°Ô∏è</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r161/three.min.js"></script>
  <script src="https://unpkg.com/three@0.161.0/examples/js/controls/PointerLockControls.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      color: white;
    }
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      font-size: 1.4rem;
      text-shadow: 0 2px 10px #000;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
      z-index: 100;
      color: #00ffff;
      font-size: 24px;
    }
    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 2rem;
      border-radius: 15px;
      text-align: center;
      z-index: 200;
    }
    #instructions button {
      background: #00ff88;
      border: none;
      padding: 1rem 2rem;
      font-size: 1.2rem;
      border-radius: 10px;
      cursor: pointer;
      margin-top: 1rem;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,0,0,0.9);
      padding: 3rem;
      border-radius: 20px;
      text-align: center;
      display: none;
      z-index: 200;
      font-size: 1.8rem;
    }
    @media (max-width: 768px) {
      #ui { font-size: 1.2rem; left: 10px; }
    }
  </style>
</head>
<body>
  <div id="crosshair">+</div>
  <div id="ui">
    ‚ö° Puntos: <span id="score">0</span> | ‚ù§Ô∏è Vida: <span id="health">100</span> | 
    üåÄ Nivel: <span id="level">1</span><br>
    üî•Fuego: <span id="killsFire">0</span> | üåäAgua: <span id="killsWater">0</span> | 
    üå™Ô∏èAire: <span id="killsAir">0</span> | ü™®Tierra: <span id="killsEarth">0</span>
  </div>

  <div id="instructions">
    <h2>¬°Elemental Slayer 3D! ‚ö°</h2>
    <p><strong>Controla al guerrero el√©ctrico</strong></p>
    <p><strong>WASD:</strong> Mover<br>
    <strong>Mouse:</strong> Mirar<br>
    <strong>Clic Izq:</strong> Disparar rayo ‚ö°</p>
    <p>Mata monstruos elementales antes de que te alcancen.</p>
    <button onclick="startGame()">¬°Empezar Batalla! üöÄ</button>
  </div>

  <div id="gameOver">
    <h2>¬°Game Over! üí•</h2>
    <p>Puntos Finales: <span id="finalScore">0</span></p>
    <button onclick="restartGame()">Jugar de Nuevo</button>
  </div>

  <script>
    // Variables globales
    let scene, camera, renderer, controls;
    let playerVelocity = new THREE.Vector3();
    let playerDirection = new THREE.Vector3();
    let monsters = [];
    let bolts = [];
    let particles = [];
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let score = 0, health = 100, level = 1;
    let spawnTimer = 0, gameRunning = false;
    let keys = {};

    // Elementos
    const elements = [
      { name: 'fire', color: 0xff4500, emissive: 0xff2200, speed: 0.8 },
      { name: 'water', color: 0x00bfff, emissive: 0x0088cc, speed: 0.6 },
      { name: 'air', color: 0xadd8e6, emissive: 0x87ceeb, speed: 1.0 },
      { name: 'earth', color: 0x8b4513, emissive: 0x654321, speed: 0.4 }
    ];

    // Inicializar escena
    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x2288ff, 20, 200);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.y = 2;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Controles FPS
      controls = new THREE.PointerLockControls(camera, renderer.domElement);
      scene.add(controls.getObject());

      // Eventos
      document.addEventListener('click', () => {
        if (!gameRunning) return;
        controls.lock();
      });

      controls.addEventListener('lock', () => {
        document.getElementById('instructions').style.display = 'none';
      });

      controls.addEventListener('unlock', () => {
        document.getElementById('instructions').style.display = 'block';
      });

      // Teclas
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      // Disparo
      document.addEventListener('mousedown', shoot);

      // Luces
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Suelo
      const groundGeometry = new THREE.PlaneGeometry(200, 200);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Paredes simples para mapa
      const wallGeometry = new THREE.BoxGeometry(200, 10, 5);
      const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
      const walls = [
        new THREE.Mesh(wallGeometry, wallMaterial),
        new THREE.Mesh(wallGeometry, wallMaterial),
        new THREE.Mesh(new THREE.BoxGeometry(5, 10, 200), wallMaterial),
        new THREE.Mesh(new THREE.BoxGeometry(5, 10, 200), wallMaterial)
      ];
      walls[0].position.z = -100;
      walls[1].position.z = 100;
      walls[2].position.x = -100;
      walls[3].position.x = 100;
      walls.forEach(wall => {
        wall.position.y = 5;
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
      });

      // Resize
      window.addEventListener('resize', onWindowResize);
    }

    function onKeyDown(event) {
      keys[event.code] = true;
    }

    function onKeyUp(event) {
      keys[event.code] = false;
    }

    function shoot() {
      if (!gameRunning || !controls.isLocked) return;

      // Rayo el√©ctrico (l√≠nea temporal)
      const boltGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -50)
      ]);
      const boltMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 4 });
      const bolt = new THREE.Line(boltGeometry, boltMaterial);
      bolt.position.copy(camera.position);
      bolt.rotation.copy(camera.rotation);
      scene.add(bolt);
      bolts.push({ mesh: bolt, life: 100 });

      // Raycast para detectar hit
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(monsters.map(m => m.mesh));

      if (intersects.length > 0) {
        const hitMonster = intersects[0].object.userData.monster;
        killMonster(hitMonster);
        createExplosion(hitMonster.mesh.position);
      }

      // Sonido simple (beep)
      playSound(800, 0.1);
    }

    function killMonster(monster) {
      score += 100 + level * 50;
      document.getElementById(`kills${monster.element.name.charAt(0).toUpperCase() + monster.element.name.slice(1)}`).textContent++;
      scene.remove(monster.mesh);
      const index = monsters.indexOf(monster);
      if (index > -1) monsters.splice(index, 1);
    }

    function createExplosion(pos) {
      // Part√≠culas el√©ctricas
      for (let i = 0; i < 30; i++) {
        const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.position.copy(pos);
        particle.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 4,
          Math.random() * 3,
          (Math.random() - 0.5) * 4
        );
        scene.add(particle);
        particles.push(particle);
      }
      playSound(400, 0.2);
    }

    function playSound(frequency, duration) {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.frequency.value = frequency;
      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + duration);
    }

    function updateMovement(delta) {
      playerVelocity.x -= playerVelocity.x * 10 * delta;
      playerVelocity.z -= playerVelocity.z * 10 * delta;

      playerDirection.z = Number(moveForward) - Number(moveBackward);
      playerDirection.x = Number(moveRight) - Number(moveLeft);
      playerDirection.normalize();

      if (moveForward || moveBackward) playerVelocity.z -= playerDirection.z * 40 * delta;
      if (moveLeft || moveRight) playerVelocity.x -= playerDirection.x * 40 * delta;

      controls.moveRight(-playerVelocity.x * delta);
      controls.moveForward(-playerVelocity.z * delta);
    }

    function spawnMonster() {
      const element = elements[Math.floor(Math.random() * elements.length)];
      const geometry = new THREE.SphereGeometry(1.5, 16, 16);
      const material = new THREE.MeshPhongMaterial({
        color: element.color,
        emissive: element.emissive,
        shininess: 100
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.position.x = (Math.random() - 0.5) * 180;
      mesh.position.z = (Math.random() - 0.5) * 180;
      mesh.position.y = 1.5;
      mesh.userData.monster = { element };
      scene.add(mesh);
      monsters.push({ mesh, element });
    }

    function updateMonsters(delta) {
      const playerPos = controls.getObject().position;

      for (let i = monsters.length - 1; i >= 0; i--) {
        const monster = monsters[i];
        const dir = new THREE.Vector3().subVectors(playerPos, monster.mesh.position).normalize();
        monster.mesh.position.add(dir.multiplyScalar(monster.element.speed * delta));

        // Rotaci√≥n
        monster.mesh.rotation.y += 0.02;

        // Colisi√≥n con player
        if (monster.mesh.position.distanceTo(playerPos) < 3) {
          health -= 10;
          scene.remove(monster.mesh);
          monsters.splice(i, 1);
        }
      }
    }

    function updateBolts(delta) {
      for (let i = bolts.length - 1; i >= 0; i--) {
        const bolt = bolts[i];
        bolt.life--;
        bolt.mesh.material.opacity = bolt.life / 100;
        if (bolt.life <= 0) {
          scene.remove(bolt.mesh);
          bolts.splice(i, 1);
        }
      }
    }

    function updateParticles(delta) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.position.add(p.userData.velocity.clone().multiplyScalar(0.016));
        p.userData.velocity.y -= 9.8 * 0.016; // Gravedad
        p.material.opacity -= 0.02;
        if (p.material.opacity <= 0) {
          scene.remove(p);
          particles.splice(i, 1);
        }
      }
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('health').textContent = health;
      document.getElementById('level').textContent = level;
    }

    function gameLoop() {
      if (!gameRunning) return;

      const delta = 0.016; // \~60fps

      if (controls.isLocked) {
        updateMovement(delta);
      }

      updateMonsters(delta);
      updateBolts(delta);
      updateParticles(delta);

      // Spawn
      spawnTimer++;
      if (spawnTimer > Math.max(120 - level * 10, 40)) {
        spawnMonster();
        spawnTimer = 0;
      }

      // Nivel up
      if (score > level * 500) level++;

      // Game over
      if (health <= 0) {
        gameRunning = false;
        document.getElementById('finalScore').textContent = score;
        document.getElementById('gameOver').style.display = 'block';
      }

      updateUI();
      renderer.render(scene, camera);
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      gameRunning = true;
      health = 100;
      score = 0;
      level = 1;
      monsters = [];
      particles = [];
      bolts = [];
      spawnTimer = 0;
      updateUI();
      gameLoop();
    }

    function restartGame() {
      document.getElementById('gameOver').style.display = 'none';
      startGame();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Iniciar
    init();

    // Chequea teclas en loop
    setInterval(() => {
      moveForward = keys['KeyW'] || keys['ArrowUp'];
      moveBackward = keys['KeyS'] || keys['ArrowDown'];
      moveLeft = keys['KeyA'] || keys['ArrowLeft'];
      moveRight = keys['KeyD'] || keys['ArrowRight'];
    }, 16);
  </script>
</body>
</html>
